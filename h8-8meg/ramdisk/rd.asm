
	TITLE	'RDDVD - RD DEVICE DRIVER'
	EJECT
***	RDDVD - RD DEVICE DRIVER.
*
*	J.G. LETWIN
*       SMBAKER
*
*       notes
*          AIO.UNI is unit number 


	XTEXT	ASCII
	XTEXT	DDDEF
	XTEXT	HOSDEF
	XTEXT	HOSEQU
	XTEXT	ECDEF
	XTEXT	ESVAL
	XTEXT	DEVDEF
	XTEXT	FILDEF
	XTEXT	PICDEF
	XTEXT	DVDDEF
	XTEXT	SETCAL
	XTEXT   PGREG

	CODE	PIC

RDCAP EQU     DT.CW+DT.CR+DT.DD+DT.RN         Read, Write, Directory, Random

	DB	DVDFLV		DEVICE DRIVER FLAG VALUE
	DB	RDCAP
	DB	00000000B	MOUNTED UNIT MASK
	DB	1		ONLY 1 UNIT
	DB	RDCAP
	DS	7		1-7:  IGNORED
	DB	DVDFLV		DEVICE DRIVER FLAG
	DW	0		No INIT Parameters		/80.09.gc/

.	SET	025Q						/80.09.gc/
	ERRNZ	*-.						/80.09.gc/
	ERRMI	DVD.STE-.					/80.09.gc/
	DS	DVD.STE-.	RESERVED AREAS			/80.09.gc/
	STL	'SET CODE'
	EJECT
***	SET CODE ENTRY POINT
*
*
*	ENTRY:	(DE)	=  LINE POINTER
*		(A)	=  UNIT NUMBER
*
*	EXIT:	(PSW)	=  'C' CLEAR IF NO ERROR
*			=  'C' SET   IF    ERROR
*
*	USES:	ALL
*

SETNTR	EQU	*
	ERRNZ	*-DVD.STE
	ANA	A
	JNZ	SET1
	MOV	B,D
	MOV	C,E		(BC) = PARAMETER LIST ADDRESS
	LXI	D,PRCTAB	(DE) = PROCESSOR TABLE ADDRESS
	LXI	H,OPTTAB	(HL) = OPTION TABLE ADDRESS
	CALL	$SOP
	RC			THERE WAS AN ERROR
	CALL	$SNA
	RZ			AT THE END OF THE LINE
	MVI	A,EC.ILO
	STC
	RET

SET1	MVI	A,EC.UUN	UNKNOWN UNIT NUMBER
	STC
	RET
	STL	'PROCESSORS'
	EJECT
***	PROCESSORS
*
	SPACE	4,10
**	HELP	-  PROCESS HELP OPTION
*
*	LIST THE VALID OPTIONS ON THE USER CONSOLE
*

HELP	CALL	$TYPTX
	DB	NL,NL,'Set Options for RD:',NL,NL
	DB	'HELP	Type this message',NL
	DB	NL
	DB	'NOTE:	This is the only valid option for the NULL device',NL
	DB	NL,ENL
	XRA	A
	RET
	STL	'SET TABLES'
	EJECT
***	SET TABLES
*
*
	SPACE	4,10
**	OPTAB	-  OPTION TABLE
*

OPTTAB	DW	OPTTABE		END OF THE TABLE
	DB	1

	DB	'HEL','P'+200Q,HELPI

OPTTABE	DB	0
	SPACE	4,10
**	PRCTAB	-  PROCESSOR TABLE
*

PRCTAB	DS	0

HELPI	EQU	*-PRCTAB/2
	DW	HELP
	SPACE	4,10
.	SET	300A
	ERRNZ	*-.
	DS	DVD.ENT-.
	STL	'MAIN ENTRY POINT'
	EJECT
**	MAIN ENTRY POINT

RDDVD	EQU	*
	ERRNZ	*-DVD.ENT	MUST BE AT THE ENTRY POINT
	CALL	$TBRA
	DB	RDREAD-*	READ
	DB	RDWRITE-*	WRITE
	DB	RDREADR-*	READR
	DB	RDOPE-*		OPENR
	DB	RDOPE-*		OPENW
	DB	RDABT-*		OPENU
	DB	RDNOP-*		CLOSE
	DB	RDNOP-*		ABORT
	DB	RDMNT-*		MOUNT
	DB	RDLOAD-*	LOAD
	DB      RDRDY-*         READY

RDABT	MVI	A,EC.DDA	DEVICE DRIVER ABORT
	STC
	RET

RDOPE	EQU	*
RDNOP	ANA	A
	RET			DO NOTHING

RDREADR	EQU	*
	CALL    DREADR
	JMP	RDREAD1
	RET


** Address calculation
**
**   in: sector number in HL
**   out: page number in A, offset in HL
**
**   secaddr = sector<<8
**   pgl  = (secaddr >> 14) & 0x7F
**
**   pgl = (sector >> 6) & 0xFF
**   ofs = (sector << 8) & 0x3F00
**
**   pgl = (L & 0xC0) >> 6
**   pgl = pgl | (H & 0x1F) << 2

CALCPG	EQU 	*
	PUSH	B		Pushes both B and C
	MOV 	A,L
	ANI 	0C0H
	RRC
	RRC
	RRC
	RRC
	RRC
	RRC
	MOV 	B,A
	MOV	A,H
	ANI	01FH
	RLC
	RLC
	ORA 	B
	POP 	B		Pops both B and C
	PUSH	PSW
	MOV     A,L
	ANI	03FH
	MOV	H,A
	MVI	L,000H
	POP	PSW
	RET

** Read Data
** BC = Byte Count
** DE = Dest Address
** HL = Block Number

RDREAD	EQU	*
	CALL    DREAD
RDREAD1 EQU     *

	PUSH	B		Save caller args
	PUSH	D
	PUSH	H
RNEXT16	MOV     A,B
	CPI	041H
	JC	LASTRD		Take the easy path, read is <= 16K+1sector
	PUSH	B
	PUSH	D
	PUSH	H
	LXI	B,04000H	Set count to 16K
	CALL	SMALLRD		Read 16K
	POP	H
	POP	D
	POP	B

	MOV	A,D		Increment DE by 0x4000
	ADI	040H
	MOV	D,A

	MOV	A,B		Decrement BC by 0x4000
	SUI	040H
	MOV	B,A

	MOV	A,L             Increment HL by 0x0040
	ADI	040H
	MOV	L,A
	MOV	A,H
	ACI	000H		We might have carried...
	MOV	H,A
	JMP	RNEXT16

LASTRD	CALL	SMALLRD		We are almost done, less than 16K+1sector remaining
	POP	H
	POP	D
	POP	B
	ANA	A
	RET

** Write Data
** BC = Byte Count
** DE = Src Address
** HL = Block Number

RDWRITE	EQU     *
	CALL	DWRITE
	PUSH	B		Save caller args
	PUSH	D
	PUSH	H
WNEXT16	MOV     A,B
	CPI	041H
	JC	LASTWR		Take the easy path, write is <= 16K+1sector
	PUSH	B
	PUSH	D
	PUSH	H
	LXI	B,04000H	Set count to 16K
	CALL	SMALLWR		Write 16K
	POP	H
	POP	D
	POP	B

	MOV	A,D		Increment DE by 0x4000
	ADI	040H
	MOV	D,A

	MOV	A,B		Decrement BC by 0x4000
	SUI	040H
	MOV	B,A

	MOV	A,L             Increment HL by 0x0040
	ADI	040H
	MOV	L,A
	MOV	A,H
	ACI	000H		We might have carried...
	MOV	H,A
	JMP	WNEXT16

LASTWR	CALL	SMALLWR		We are almost done, less than 16K+1sector remaining
	POP	H
	POP	D
	POP	B
	ANA	A
	RET

RDLOAD	EQU	*
        CALL    DLOAD
	CALL    PGINIT
	ANA	A
	RET

RDRDY	EQU	*
	CALL	DRDY
	ANA	A
	RET

RDMNT	EQU	*
	CALL	DMNT
	ANA	A
	RET

** Read/Write functions

SMALLRD	EQU	*
	MOV	A,B
	ORA	C
	JZ	SROUT		Asking to write 0 bytes

	CALL    CALCPG
	CALL	DPAGE
	OUT	RD00K,A		Map page0 to virt-page in ramdisk
	INR	A
	OUT	RD16K,A		Always allocate two pages, so we can handle writes that are greater than 16K

	DI
	MVI	A,083H		Select the proper bank, and turn on paging
	OUT     RD00KH,A
	OUT	RD16KH,A

RLOOP   MOV     A,M             Load value in memory location HL into A
	STAX	D               Store value in A into memory location DE
	INX	D
	INX	H
        DCX     B
	MOV	A,B
	ORA	C
	JNZ	RLOOP

	MVI     A,000H
	OUT	RD00KH,A        disable paging and map page0 back to virt-page0
	OUT     RD00K,A		... and bank 0
	OUT     RD16KH,A        ... and page 1 back to bank 0
	INR	A
	OUT	RD16K,A		... and page 1 back to virt-page1
	EI
SROUT	RET

SMALLWR	EQU	*
	MOV	A,B
	ORA	C
	JZ	SWOUT		Asking to write 0 bytes

	CALL    CALCPG
	CALL	DPAGE
	OUT	WR00K,A		Map page0 to virt-page in ramdisk
	INR	A
	OUT	WR16K,A		Always allocate two pages, so we can handle writes that are greater than 16K

	DI
	MVI	A,083H		BANK 3, page enable
	OUT     WR00KH,A
	OUT	WR16KH,A

WLOOP   LDAX	D               Load value in memory location DE into A
	MOV     M,A             Store value in A into memory location HL
	INX	D
	INX	H
        DCX     B
	MOV	A,B
	ORA	C
	JNZ	WLOOP

	MVI     A,000H		
	OUT	WR00KH,A        disable paging and map page0 back to virt-page0
	OUT     WR00K,A		... and bank 0
	OUT     WR16KH,A        ... and page 1 back to bank 0
	INR	A
	OUT	WR16K,A		... and page 1 back to virt-page1
	EI

SWOUT	RET

** Library stuff

	XTEXT	PGMAP

** Debug messages

DLOAD   EQU	*
 	PUSH    PSW
	PUSH	H
	LXI	H,MLOAD
	SCALL   .PRINT
	POP	H
	POP	PSW
	RET

DREADR	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MREADR
	SCALL   .PRINT
	POP	H
	CALL	PHEXHL
	PUSH	H
	LXI	H,MDEST
	SCALL	.PRINT
	CALL    PHEXDE
	LXI	H,MCOUNT
	SCALL   .PRINT
	CALL    PHEXBC
	MVI	A,012Q
	SCALL	.SCOUT
	POP	H
	POP	PSW
	RET

DREAD	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MREAD
	SCALL   .PRINT
	POP	H
	CALL	PHEXHL
	PUSH	H
	LXI	H,MDEST
	SCALL	.PRINT
	CALL    PHEXDE
	LXI	H,MCOUNT
	SCALL   .PRINT
	CALL    PHEXBC
	MVI	A,012Q
	SCALL	.SCOUT
	POP	H
	POP	PSW
	RET

DSMALLR	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MSREAD
	SCALL   .PRINT
	POP	H
	CALL	PHEXHL
	PUSH	H
	LXI	H,MDEST
	SCALL	.PRINT
	CALL    PHEXDE
	LXI	H,MCOUNT
	SCALL   .PRINT
	CALL    PHEXBC
	MVI	A,012Q
	SCALL	.SCOUT
	POP	H
	POP	PSW
	RET

DWRITE	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MWRITE
	SCALL   .PRINT
	POP	H
	CALL	PHEXHL
	PUSH	H
	LXI	H,MSRC
	SCALL	.PRINT
	CALL    PHEXDE
	LXI	H,MCOUNT
	SCALL   .PRINT
	CALL    PHEXBC
	MVI	A,012Q
	SCALL	.SCOUT
	POP	H
	POP	PSW
	RET

DSMALLW	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MSWRITE
	SCALL   .PRINT
	POP	H
	CALL	PHEXHL
	PUSH	H
	LXI	H,MSRC
	SCALL	.PRINT
	CALL    PHEXDE
	LXI	H,MCOUNT
	SCALL   .PRINT
	CALL    PHEXBC
	MVI	A,012Q
	SCALL	.SCOUT
	POP	H
	POP	PSW
	RET

DRDY	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MRDY
	SCALL   .PRINT
	POP	H
	POP	PSW
	RET

DMNT	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MMNT
	SCALL   .PRINT
	POP	H
	POP	PSW
	RET

DBACK	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MBACK
	SCALL   .PRINT
	POP	H
	POP	PSW
	RET

DCOPD	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MCOPD
	SCALL   .PRINT
	POP	H
	POP	PSW
	RET

DBIGR	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MBIGR
	SCALL   .PRINT
	POP	H
	POP	PSW
	RET

DBIGW	EQU	*
	PUSH    PSW
	PUSH	H
	LXI	H,MBIGW
	SCALL   .PRINT
	POP	H
	POP	PSW
	RET

DPAGE	EQU	*
	PUSH    PSW
	PUSH	H
	PUSH    PSW		The .PRINT will change A
	LXI	H,MPAGE
	SCALL   .PRINT
	POP	PSW		Restore A so we can print it
	CALL	PHEXA
	LXI	H,MADDR
	SCALL	.PRINT
	POP	H
	CALL	PHEXHL
	MVI	A,012Q
	SCALL	.SCOUT
	POP	PSW
	RET

PHEXA	PUSH	PSW
	RLC
	RLC
	RLC
	RLC
	CALL	PHEXA0
	POP	PSW
PHEXA0	ANI	00FH
	ADI	090H
	DAA
	ACI	040H
	DAA
	SCALL    .SCOUT
	RET

PHEXHL	PUSH	PSW
	MOV	A,H
	CALL	PHEXA
	MOV	A,L
	CALL	PHEXA
	POP	PSW
	RET

PHEXDE	PUSH	PSW
	MOV	A,D
	CALL	PHEXA
	MOV	A,E
	CALL	PHEXA
	POP	PSW
	RET

PHEXBC	PUSH	PSW
	MOV	A,B
	CALL	PHEXA
	MOV	A,C
	CALL	PHEXA
	POP	PSW
	RET

MLOAD	DB	12Q,'RD: LOAD',212Q
MREAD   DB      12Q,'RD: READ BLK','='+200Q
MSREAD  DB      12Q,'RD: SMALL READ BLK','='+200Q
MDEST   DB      ' DEST','='+200Q
MSRC    DB      ' SRC','='+200Q
MCOUNT	DB	' COUNT','='+200Q
MREADR  DB      12Q,'RD: READ REGARDLESS BLK','='+200Q
MWRITE  DB      12Q,'RD: WRITE BLK','='+200Q
MSWRITE DB      12Q,'RD: WRITE BLK','='+200Q
MRDY    DB      12Q,'RD: READY',212Q
MMNT    DB      12Q,'RD: MOUNT',212Q
MPAGE   DB      '    PAGE','='+200Q
MADDR   DB      ' ADDR','='+200Q
MBACK	DB	'BACK',212Q
MCOPD	DB	'COPIED',212Q

MBIGR	DB	'RD: BIGREAD',212Q
MBIGW	DB	'RD: BIGWRITE',212Q

	XTEXT	TBRA
	XTEXT	TYPTX
	DB	'RW'		DUMY ADDRESS FOR RELOCATION
	DS	32		PATCH AREA

	LON	G

	END
