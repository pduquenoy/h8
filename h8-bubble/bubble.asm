	TITLE	'BUBBLE - BUBBLE MEMORY TOOL'
	EJECT

* BASED ON PROGRAM WRITTEN BY CRAIG ANDREWS, 2020
* COPYRIGHT 2019 (C) OF CRAIG ANDREWS ALL RIGHTS RESERVED

	XTEXT	HOSDEF
	XTEXT	HOSEQU
* stuff below is for cmdline parsing
	XTEXT	ASCII
	XTEXT	DIRDEF
	XTEXT	ESVAL
	XTEXT	ECDEF
	XTEXT	IOCDEF
	XTEXT	BUBDEF

	ORG	04000H

ENTRY	LXI	H,BANMSG
	SCALL	.PRINT

	CALL	BBLABRT	* ABORT ANY COMMANDS BEING PROCESSED
	CALL	HO
	CALL	BBLABRT	* ABORT ANY COMMANDS BEING PROCESSED
	CALL	HO

	CALL	BBLINIT	* INITIALIZE THE BUBBLE
	CALL	HO		* OUTPUT RETURN VALUE

BUBZERO EQU	*
	SUI	'0'
	MOV	B,A		* SAVE STARTING INCREMENTING VALUE
	LXI	H,3000H
FILLLP EQU	*
	MOV	M,B
	INX	H
	INR	B
	MOV	A,H
	CPI	40H
	JNZ	FILLLP

	LXI	H,2000H		* FILL 2000 TO 2FFF WITH 00H
FILLLP1 EQU	*
	MVI	M,00H
	INX	H
	MOV	A,H
	CPI	30H
	JNZ	FILLLP1
	JMP	CMDLOOP	* DONE

* main command loop
CMDLOOP EQU	*
	CALL	PROMPT		* SEND PROMPT TO TERMINAL
	CALL	CI
	CALL	CO

	CPI	'C'		* IS COMMAND TO CONFIGURE?
	JZ	BUBCONF		*  YES, CONFIGURE

	CPI	'D'		* IS COMMAND DUMP MEMORY?
	JZ	CMDD		*  YES, DUMP

	CPI	'I'		* IS COMMAND GET STATUS?
	CZ	BBLINIT		*  YES, GET AND DISPLAY

	CPI	'S'		* IS COMMAND GET STATUS?
	JZ	BUBSTAT		*  YES, GET AND DISPLAY

	CPI	'F'		* IS COMMAND TO FILL?
	JZ	BUBFIL		*  YES, FILL

	CPI	'G'		* IS COMMAND TO GET FIFO?
	JZ	BUBGET		*  YES, GET 40 BYTES

	CPI	'R'		* IS COMMAND TO READ?
	JZ	BUBRD	*  YES, READ

	CPI	'T'		* IS COMMAND TO TEST?
	JZ	BUBTEST	*  YES, TEST

	CPI	'W'		* IS COMMAND TO WRITE?
	JZ	BUBWRT	*  YES, WRITE


	CPI	'Z'		* IS COMMAND TO ZERO BUFFERS?
	JZ	BUBZERO		*  YES, CLEAN BUFFERS

	CPI	'#'		* IS THIS A NUMBERED COMMAND
	JZ	BUBNUMC	*  YES, SEND NUMBERED COMMAND

	MVI	A,BELL		* UNRECOGNIZED
	CALL	CO
	MVI	A,'?'
	CALL	CO
	JMP	CMDLOOP

* Configure the 7220 parametric registers
BUBCONF	EQU	*
*  REGISTER B = 01H -> 1 PAGE TRANSFER
*  REGISTER C = 10H -> 1 2 CHANNELS (WHOLE BUBBLE)
*  REGISTER D = 08H -> 1 STANDARD TRANSFER RATE
*  REGISTER E = 00H -> 1 PAGE 0
*  REGISTER F = 00H -> 1 FIRST BUBBLE

	MVI	A,0BH		* SELECT BLOCK LENGTH LSB REGISTER
	OUT	BBLCS
	MVI	A,01H
	OUT	BBLDAT		* SEND BLOCK LENGTH LSB
	MVI	A,10H
	OUT	BBLDAT		* SEND BLOCK LENGTH MSB
	MVI	A,08H
	OUT	BBLDAT		* SEND ENABLE
	MVI	A,00H
	OUT	BBLDAT		* SEND ADDRESS PAGE (LSB)
	MVI	A,00H
	OUT	BBLDAT		* SEND ADDRESS BUBBLE (MSB)
	JMP	CMDLOOP	* DONE


BUBFIL EQU	*
	LXI	H,BUBFILM
	MVI	B,40D		* FILL 40 BYTES IN BUBBLE FIFO
BUBFIL1 EQU	*
	MOV	A,M		* FILL CHARACTER IS COUNTER
	OUT	BBLDAT		* SEND TO BUBBLE
	INX	H
	DCR	B
	JNZ	BUBFIL1	* DO UNTIL DONE
	MVI	A,00H
	OUT	BBLDAT		* 00H IN BYTE 41 REQUIRED FOR DIAGNOSTIC WRITE BOOTLOOP
	JMP	CMDLOOP	* THEN RETURN

BUBFILM	DB	'FIFO BUFFER Fill 9 8 7 6 5 4 3 2 1 0 END'


* Bubble 7220 Commands used with the '#' command
* 0 - Write Boot Register Masked
* 1 - Initialize
* 2 - Read Bubble Data
* 3 - Write Bubble Data
* 4 - Reed Seek
* 5 - Read Bootloop Register
* 6 - Write Bootloop Register
* 7 - Write Bootloop
* 8 - Read FSA Status
* 9 - Abort
* A - Write Seek
* B - Read Bootloop
* C - Read Corrected Data
* D - Reset FIFO
* E - MBM Purge
* F - Software Reset
BUBNUMC EQU	*
	CALL	CI		* GET COMMAND NUMBER
	CALL	TOHEX
	ANI	0FH		* CLEAR TOP HALF
	ORI	10H		* SET BIT 4
	OUT	BBLCS		* SEND TO BUBBLE
	CALL	HO		* DISPLAY VALUE SENT TO USER
	JMP	CMDLOOP	* THEN GET NEXT COMMAND


* read the FIFO into the input buffer (0x4037)
BUBGET	EQU	*
	MVI	B,68D		* NUMBER OF BYTES TO READ
	LXI	H,INPBUF	* INPUT BUFFER
BUBGET1 EQU	*
	IN	BBLDAT		* GET DATA BYTE
	MOV	M,A		* SAVE TO RAM
	INX	H		* POINT TO NEXT MEMORY
	DCR	B		* ONE DONE
	JNZ	BUBGET1	* LOOP IF MORE
	JMP	CMDLOOP	* RETURN IF DONE

* get the 7220 status
BUBSTAT EQU	*
	IN	BBLCS		* GET STATUS
	CALL	HO		* DISPLAY TO USER AS HEX
	CALL	SENDSPC
	CALL	BOB
	JMP	CMDLOOP


* USER INTERACTIVE WRITE TO THE BUBBLE
* 	TO USE SUBROUTINE:
* 	BARL <- LSB OF BUBBLE ADDRESS
* 	BARH <- MSB OF BUBBLE ADDRESS
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	DE <- STARTING MEMORY ADDRESS OF SOURCE DATA
* 	CALL BBLWRIT

BUBWRT EQU	*
	LXI	H,BWRMSGP	* REQUEST BUBBLE PAGE FROM USER
	CALL	SENDSTR
	CALL	GETHEXW	* GET IT
	SHLD	BAR		* SAVE IN RAM BUFFER FOR BUBBLE ROUTINES

	LXI	H,BWRMSGS	* ASK FOR DATA SOURCE ADDRESS FROM USER
	CALL	SENDSTR
	CALL	GETHEXW	* GET IT
	XCHG			* PUT INTO DE
	LXI	H,BWRMSGH	* ASK FOR NUMBER OF BYTES TO WRITE
	CALL	SENDSTR
	CALL	GETHEXW	* GET IT
	CALL	NEWLINE
	MVI	A,'P'		* PAGE
	CALL	CO
	LDA	BARH
	CALL	HO
	LDA	BARL
	CALL	HO
	MVI	A,'S'		* SOURCE ADDRESS
	CALL	CO
	CALL	SENDDE
	MVI	A,'#'		* # OF BYTES
	CALL	CO
	CALL	SENDHL
	CALL	NEWLINE
	CALL	BBLWRIT	* WRITE TO BUBBLE
	MOV	B,A		* SAVE RETURN CODE
	MVI	A,'S'		* WRITE RETURN CODE STATUS
	CALL	CO
	MOV	A,B		* RESTORE RETURN CODE
	CALL	HO		* DISPLAY RESULT OF CALL
	CALL	NEWLINE
	JMP	CMDLOOP	* DONE



* USER INTERACTIVE READ FROM THE BUBBLE
* 	TO USE SUBROUTINE:
* 	BARL <- LSB OF BUBBLE ADDRESS
* 	BARH <- MSB OF BUBBLE ADDRESS
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	DE <- STARTING MEMORY ADDRESS OF DESTINATION RAM
* 	THEN CALL BBLREAD
BUBRD EQU *
	LXI	H,BWRMSGP	* REQUEST BUBBLE PAGE FROM USER
	CALL	SENDSTR
	CALL	GETHEXW	* GET IT
	SHLD	BAR		* SAVE IN RAM BUFFER FOR BUBBLE ROUTINES

	LXI	H,BWRMSGD	* ASK FOR DATA DESTINATION ADDRESS FROM USER
	CALL	SENDSTR
	CALL	GETHEXW	* GET IT
	XCHG			* PUT INTO DE
	LXI	H,BWRMSGH	* ASK FOR NUMBER OF BYTES TO WRITE
	CALL	SENDSTR
	CALL	GETHEXW	* GET IT
	CALL	NEWLINE
	MVI	A,'P'		* PAGE
	CALL	CO
	LDA	BARH
	CALL	HO
	LDA	BARL
	CALL	HO
	MVI	A,'D'		* DESTINATION ADDRESS
	CALL	CO
	CALL	SENDDE
	MVI	A,'#'		* # OF BYTES
	CALL	CO
	CALL	SENDHL
	CALL	NEWLINE
	CALL	BBLREAD	* READ FROM THE BUBBLE
	MOV	B,A		* SAVE RETURN CODE
	MVI	A,'S'		* READ RETURN CODE
	CALL	CO
	MOV	A,B		* RESTORE RETURN CODE
	CALL	HO		* DISPLAY RESULT OF CALL
	CALL	NEWLINE
	JMP	CMDLOOP	* DONE


BWRMSGH	DB	LF,'NUMBER OF BYTES 0x0000-0x43BC - 0x',200Q
BWRMSGS	DB	LF,'SOURCE ADDRESS 0x0000-0xFFFF - 0x',200Q
BWRMSGD	DB	LF,'DESTINATION ADDRESS 0x0000-0xFFFF - 0x',200Q
BWRMSGP	DB	LF,'BUBBLE STARTING PAGE ADDRESS 0x0000-0X07FF- 0x',200Q



* BUBBLE QUICK TEST
* WRITE THE PAGE NUMBER TO EACH TWO-BYTE WORD AND THEN READ BACK
* CHECK IF READ-WRITE MATCH AND MOVE ON IF OK OR SEND MESSAGE IF NOT
BUBTEST EQU	*	* WRITE AND READ EACH BIT IN BUBBLE
	XRA	A		* CLEAR ACCUMULATOR
	STA	BARL		* SAVE BUBBLE STARTING PAGE NUMBER
	STA	BARH
	CALL	NEWLINE
	LXI	H,BUBTMSG	* MESSAGE TO USER
	CALL	SENDSTR

BUBTFIL EQU *			* FILL BUFFER WITH TWO-BYTE PAGE NUMBER
	LHLD	BAR
	CALL	SENDHL

	XCHG			* PAGE ADDRESS -> DE
	LXI	H,2000H		* DATA BUFFER

BUBTFLP EQU *
	MOV	M,D		* BIG ENDIAN FILL OF BUFFER WITH PAGE NUMBER
	INX	H
	MOV	M,E
	INX	H
	MOV	A,L		* FILL BYTE NUMBER
	CPI	68D		* LAST FILL LOCATION
	JNZ	BUBTFLP	* LOOP UNTIL DONE


	LXI	H,0068D		* NUMBER OF BYTES TO WRITE
	LXI	D,2000H		* START OF FILL BUFFER DATA
	CALL	BBLWRIT	* WRITE TO BUBBLE


	LXI	H,0068D		* NUMBER OF BYTES TO READ
	LXI	D,2100H		* START OF OUTPUT BUFFER DATA
	CALL	BBLREAD	* READ FROM BUBBLE

BUBTSKP EQU	*


* NOW CHECK IF BUFFERS MATCH, SEND MSG WITH EACH ERROR
	LXI	H,2000H		* ORIGINAL DATA LOCATION
	LXI	D,2100H		* READBACK DATA LOCATION

BUBTCHK EQU	*
	MOV	A,M		* GET ORIGINAL DATA
	XCHG			* HL=READBACK, DE=ORIGINAL
	CMP	M		* COMPARE ORIGINAL DATA WITH READBACK
	XCHG			* HL=ORIGINAL, DE=READBACK
	CNZ	BUBTFAI	* IF NOT A MATCH, DISPLAY ERROR
	INX	H
	INX	D
	MOV	A,L
	CPI	68D
	JNZ	BUBTCHK

	MVI	A,BS		* BACKSPACE OVER PAGE NUMBER
	CALL	CO
	CALL	CO
	CALL	CO
	CALL	CO
	LHLD	BAR		* GET BUBBLE PAGE
	INX	H		* INCREMENT
	SHLD	BAR		* SAVE PAGE NUMBER TO BUFFER

	MOV	A,H
	CPI	08H		* IS THE HIGH BYTE ONE PAST THE LAST BUBBLE PAGE?
	JNZ	BUBTFIL	*  NO, LOOP AGAIN
	MOV	A,L		* GET LOW BYTE
	CPI	00H		* IS THE LOW BYTE ONE PAST THE LAST BUBBLE PAGE?
	JNZ	BUBTFIL	*  NO, LOOP AGAIN
	JMP	CMDLOOP	*  YES, DONE SO RETURN

BUBTFAI EQU	*
	MOV	C,L		* BYTE NUMBER INTO C
	LXI	H,BTMFAB
	CALL	SENDSTR

	MOV	A,C		* GET BYTE NUMBER
	CALL	HO

	LXI	H,BTMFAW
	CALL	SENDSTR

	MVI	H,20H		* RESTORE HL TO ORIGINAL BUFFER
	MOV	L,C		*
	MOV	A,M		* GET ORIGINAL DATA
	CALL	HO
	LXI	H,BTMFAR
	CALL	SENDSTR
	MVI	H,21H		* HL = READBACK
	MOV	L,C		* RESTORE HL TO READBACK BUFFER
	MOV	A,M
	CALL	HO
	CALL	NEWLINE
	LXI	H,BUBTMSG	* OUTPUT PAGE MESSAGE AGAIN
	CALL	SENDSTR
	LHLD	BAR		* GET PAGE NUMBER AGAIN
	CALL	SENDHL		* DISPLAY FOR NEXT LOOP
	MVI	H,20H		* RESTORE BUFFER ADDRESSES
	MOV	L,C



	RET

BUBTMSG	DB	'TESTING PAGE --',200Q
BTMFAB	DB	'  FAILED ON BYTE --',200Q
BTMFAW	DB	'  WRITE VALUE --',200Q
BTMFAR	DB	'  READ VALUE --',200Q


* The following are bubble I/O routines
* TO USE THE BUBBLE ROUTINES:
* THE BUBBLE MUST FIRST BE INITIALIZED BY CALLING BBLINIT BEFORE ANYTHING ELSE.
* BBLINIT WILL CONFIGURE THE RAM BUFFER TO THEIR DEFAULT VALUES
*
* AFTER INITIALIZED,
* BBLWRIT IS USED TO COPY FROM MEMORY INTO THE BUBBLE
* BBLREAD IS USED TO COPY FROM THE BUBBLE AND STORE INTO RAM
*
* BEFORE BBLWRIT OR BBLREAD ARE CALLED, THE FOLLOWING PARAMETRIC VALUES
* MUST BE STORED TO THE CORRESPONDING BUFFERS IN RAM OR IN THE REGISTERS
* 	BARL	BUBBLE ADDRESS REGISTER LSB
* 	BARH	BUBBLE ADDRESS REGISTER MSB
* 	REGISTER DE = STARTING MEMORY ADDRESS OF DATA TRANSFER
* 	REGISTER HL = NUMBER OF BYTES TO BE TRANSFERRED
* AFTER EITHER READ OR WRITE REGISTER A WILL CONTAIN THE RESULTING 7220 STATUS




* ********************************************************************
* **************  BUBBLE ABORT  *******************
*   NAME: BBLABRT
*   FUNCTION:SEND THE ABORT COMMAND TO THE 7220
*   INPUTS: NONE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:SEND THE ABORT COMMAND TO 7220
* * ********************************************************************
BBLABRT EQU 	*
	CALL BBLAB1
	CALL BBLAB1
	RET


BBLAB1	EQU	*
*  MVI	A,'A'			* UNCOMMENT FOR VERBOSE
*  CALL	CO			* UNCOMMENT FOR VERBOSE
	PUSH	D		* DE USED FOR TIMEOUT COUNTER, SAVE
	LXI	D,0FFFFH	* LOAD COUNTER START VALUE
	MVI	A,19H		* ABORT COMMAND FOR 7220
	OUT	BBLCS		* SEND TO COMMAND REGISTER
BBLABBS EQU *
	IN	BBLCS		* GET BUBBLE STATUS REGISTER
	RLC			* TEST BUSY BIT =1
	JC	BBLABP	*  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	D		*  ADD ANY SET BITS IN D
	ORA	E		*  THEN SAME FOR E
	JNZ	BBLABBS	* TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E1H		* RETURN WITH ERROR 1
	JMP	BBLABDN	* DONE, BUT WITH TIMEOUT ERROR

BBLABP EQU *
	IN	BBLCS		* READ STATUS REGISTER
	CPI	BSROCCM	* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLABDN	* DONE WITH SUCCESS
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR A
	ORA	D		*  ADD ANY SET BETS IN D
	ORA	E		*  ADD ANY SET BITS IN E
	JNZ	BBLABP	* IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E2H		* RETURN WITH ERROR 2

BBLABDN EQU *
	POP	D
*  CALL	HO			* UNCOMMENT FOR VERBOSE
*  CALL	NEWLINE			* UNCOMMENT FOR VERBOSE

	RET			* RETURN

* ********************************************************************
* **************  BUBBLE FIFO RESET  *******************
*   NAME: BBLFFR
*   FUNCTION:SEND THE FIFO RESET COMMAND TO THE 7220
*   INPUTS: NONE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:SEND THE FIFO RESET COMMAND TO THE 7220 AND WAIT FOR
* 	THE OP-COMPLETE FLAG OR (BUSY OR COMPLETE) TIMEOUT, WHATEVER COMES FIRST
* * ********************************************************************
BBLFFR EQU *
*  MVI	A,'F'			* UNCOMMENT FOR VERBOSE
*  CALL	CO
	PUSH	D		* DE USED FOR TIMEOUT COUNTER, SAVE
	LXI	D,0FFFFH	* LOAD COUNTER START VALUE
	MVI	A,1DH		* FIFO RESET COMMAND FOR 7220
	OUT	BBLCS		* SEND TO COMMAND REGISTER
BBLFFRB EQU	*
	IN	BBLCS		* GET BUBBLE STATUS REGISTER
	RLC			* TEST BUSY BIT =1
	JC	BBLFFRP	*  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	D		*  ADD ANY SET BITS IN D
	ORA	E		*  THEN SAME FOR E
	JNZ	BBLFFRB	* TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E3H		* RETURN WITH ERROR 3
	JMP	BBLFFRD	* DONE, BUT WITH TIMEOUT ERROR

BBLFFRP EQU *
	IN	BBLCS		* READ STATUS REGISTER
	CPI	BSROCCM	* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLFFRD	* DONE WITH SUCCESS
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR A
	ORA	D		*  ADD ANY SET BETS IN D
	ORA	E		*  ADD ANY SET BITS IN E
	JNZ	BBLFFRP	* IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E4H		* RETURN WITH ERROR 4 IN ACCUMULATOR

BBLFFRD EQU *
	POP	D
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  CALL NEWLINE
	RET			* RETURN


* ********************************************************************
* **************  BUBBLE INITIALIZE  *******************
*   NAME: BBLINIT
*   FUNCTION:INITIALIZES BUBBLE MEMORY SYSTEM
*   INPUTS: NONE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: BBLABRT, BBLPRL
*   DESCRIPTION:THIS COMMAND IS REQURIED AFTER POWERUP AND MUST PRECEED
* 	ALL OTHER COMMANDS. IT FIRST LOADS THE RAM PARAMETER BUFFERS WITH
* 	THE REQUIRED DEFAULT VALUES FOR INITIALIZATION, THEN ABORTS ANY
* 	EXISTING BUBBLE COMMAND THAT MAY BE PROCESSING, AND THEN INITIALIZES
* 	THE BUBBLE.  IT WILL RETURN IF ANYTHING RESULTS IN A TIMEOUT OR ANY
* 	STATUS OTHER THAN AN OPERATION COMPLETE STATUS.
* * ********************************************************************
BBLINIT EQU *
*  MVI	A,'I'			* UNCOMMENT FOR VERBOSE
*  CALL	CO
	PUSH	D		* DE USED FOR TIMEOUT COUNTER, SAVE

	MVI	A,BBLRLV	* GET DEFAULT VALUE FOR BLOCK LENGTH LSB
	STA	BBLRL		* BUBBLE BLOCK LENGTH LSB -> BUFFER
	MVI	A,BBLEV	* GET ENABLE BYTE
	STA	BBLER		* BUBBLE ENABLE -> BUFFER
	MVI	A,BARLV	* GET DEFAULT BUBBLE ADDRESS LSB
	STA	BARL		* BUBBLE ADDRESS LSB-> BUFFER
	MVI	A,BARHV	* GET DEFAULT BUBBLE ADDRESS MSB
	STA	BARH		* BUBBLE ADDRESS MSB-> BUFFER
	CALL	BBLABRT	* ABORT ANY COMMANDS BEING PROCESSED
	CPI	BSROCCM	* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLINID	* IF DIDN'T FINSIH ABORT, WE ARE DONE WITH ERROR
	CALL	BBLPRL		* PARAMETRIC REGISTER LOAD
	LXI	D,0FFFFH	* LOAD TIMEOUT LOOP COUNTER
	MVI	A,11H		* LOAD INITIALIZE BUBBLE COMMAND
	OUT	BBLCS		* SEND INITIALIZE COMMAND TO BUBBLE

BBLINIB EQU *
	IN	BBLCS		* GET BUBBLE STATUS REGISTER
	RLC			* TEST BUSY BIT =1
	JC	BBLINIP	*  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	D		*  ADD ANY SET BITS IN D
	ORA	E		*  THEN SAME FOR E
	JNZ	BBLINIB	* TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E5H		* RETURN WITH ERROR 5
	JMP	BBLINID	* DONE, BUT WITH TIMEOUT ERROR

BBLINIP EQU *
	IN	BBLCS		* READ STATUS REGISTER
	CPI	BSROCCM	* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLINID	* DONE WITH SUCCESS
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR A
	ORA	D		*  ADD ANY SET BETS IN D
	ORA	E		*  ADD ANY SET BITS IN E
	JNZ	BBLINIP	* IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E6H

BBLINID EQU *

	POP	D
*  CALL	HO			* UNCOMMENT FOR VERBOSE
*  CALL	NEWLINE
	RET			* RETURN


* ********************************************************************
* **************  BUBBLE PARAMETRIC REGISTER LOAD  *******************
*   NAME: BBLPRL
*   FUNCTION: FILLS BUBBLE PARAMETRIC REGISTERS WITH VALUES IN RAM BUFFER
*   INPUTS: NONE
*   OUTPUTS: NONE
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:SENDS THE PARAMETRIC REGISTER VALUES HELD IN RESERVED RAM
* 	LOCATIONS TO BUBBLE 7220. ENDS WITH PARAMETRIC REGISTER ADDRESS POINTING
* 	TO 7220 FIFO
* 	THE ENABLE REGISTER AND BLOCK LENGTH MSB ARE HARD CODED
* * ********************************************************************
BBLPRL EQU *
*  MVI A,'P'			* UNCOMMENT FOR VERBOSE
*  CALL CO
	MVI	A,BBLRLA	* GET STARTING REGISTER NUMBER
	OUT	BBLCS		* SET 7220 REGISTER POINTER TO BLR LSB
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  mvi a,' '
*  CALL CO
*  MVI A,'b'
*  CALL CO
	LDA	BBLRL		* GET BLOCK LENGTH LSB VALUE FROM RAM BUFFER
	OUT	BBLDAT		* LOAD IN BLOCK LENGTH LSB REGISTER
*  CALL HO			* UNCOMMENT FOR VERBOSE
	MVI	A,BBLRHV	* GET BLOCK LENGTH MSB VALUE
	OUT	BBLDAT		* LOAD IN BLOCK LENGTH MSB REGISTER
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  mvi a,' '
*  CALL CO			* UNCOMMENT FOR VERBOSE
*  MVI A,'e'
*  CALL CO			* UNCOMMENT FOR VERBOSE
	LDA	BBLER		* GET ENABLE REGISTER VALUE
	OUT	BBLDAT		* LOAD IN BUBBLE ENABLE REGISTER
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  mvi a,' '
*  CALL CO			* UNCOMMENT FOR VERBOSE
*  MVI A,'a'
*  CALL CO
	LDA	BARL		* GET ADDRESS LSB
	OUT	BBLDAT		* LOAD IN BUBBLE AR_L REGISTER
*  CALL HO
	LDA	BARH		* GET ADDRESS MSB
	OUT	BBLDAT		* LOAD INTO BUBBLE ADDRESS MSB REGISTER
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  mvi a,' '
*  CALL CO
*  MVI	A,'s'
*  CALL	CO			* UNCOMMENT FOR VERBOSE

	IN	BBLCS		* GET STATUS BEFORE RETURN
*  CALL	HO			* UNCOMMENT FOR VERBOSE

	RET			* DONE LOADING 7220 REGISTERS, RETURN



* ********************************************************************
* **************  BUBBLE GET DATA AND SAVE INTO RAM  *******************
*   NAME: BBLGET
*   FUNCTION: READS BUBBLE DATA AND PUTS INTO RAM
*   INPUTS: DE=STARTING ADDRESS OF RAM, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: NONE
*   USER IO: NONE
*   DESTROYS: A,H,L, F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	LOAD LSB OF BLOCK LENGTH IN BBLRL
* 	LOAD LSB OF BUBBLE ADDRESS INTO BARL
* 	LOAD MSB OF BUBBLE ADDRESS INTO BARH
* 	LOAD NUMBER OF BYTES TO TRANSFER INTO HL REGISTER PAIR
* 	LOAD STARTING ADDRESS OF RAM TO SAVE DATA INTO DE REGISTER PAIR
* 	CALL BBLREAD
* * ********************************************************************
BBLGET EQU *
*  CALL	NEWLINE			* UNCOMMENT FOR VERBOSE
*  MVI	A,'R'			* UNCOMMENT FOR VERBOSE
*  CALL	CO			* UNCOMMENT FOR VERBOSE

	PUSH	D		* SAVE NUMBER OF BYTES
	PUSH	B		* USED IN THIS ROUTINE
	LXI	B,0FFFFH	* LOAD TIMEOUT COUNTER
	MVI	A,12H		* LOAD READ BUBBLE MEMORY DATA COMMAND
	OUT	BBLCS		* SEND COMMAND TO 7220 COMMAND REGISTER
BBLGETB EQU *
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SEE IF ANY B BITS SET
	ORA	C		* SEE IF ANY C BITS SET
	MVI	A,0EAH		* PRELOAD ERROR CODE
	JZ	BBLGETD	* IF ZERO, DONE BECAUSE OF TIMEOUT ERROR
	IN	BBLCS		* OTHERWISE, GET STATUS REGISTER
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLGETB	* LOOP UNTIL BUBBLE SETS BUSY INDICATING RECEIPT


BBLGETP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLGETR	* SOMETHING IN FIFO, SO READ BYTE

	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EBH		* PRELOAD ERROR B JUST IN CASE
	JNC	BBLGETD	* NOT BUSY, SO DONE BUT WITH ERROR

	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0ECH		* PRELOAD ERROR C JUST IN CASE
	JZ	BBLGETD	* DONE DUE TO TIMEOUT ERROR
	JMP	BBLGETP	* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLGETR EQU *

	IN	BBLDAT		* READ BYTE FROM BUBBLE
	STAX	D		* MOVE DATA BYTE INTO DE REGISTER ADDRESS
	INX	D		* INCREMENT TO NEXT MEMORY ADDRESS

	DCX	H		* DECREMENT DATA BYTE COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* ADD ANY BITS THAT ARE SET IN H
	ORA	L		* AND THEN ANY BITS SET IN L
	JNZ	BBLGETP		* LOOP UNTIL ALL BYTES ARE DONE OR ERROR OCCURS

*                                 NOW FLUSH OUT THE REMAINDER OF THE PAGE FROM FIFO
	LDA	BBLPUC		* GET THE PAGE UNUSED COUNT
	MOV	L,A		* PUT INTO L
	ORA	A		* SEE IF THERE IS A REMAINDER
 	JZ	BBLGETD	* NOPE, ALL DONE


BBLGFP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLGFRD	* SOMETHING IN FIFO, GET IT
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EDH		* PRELOAD ERROR D
	JNC	BBLGETD	* NOT BUSY SO....DONE I GUESS?
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0EEH		* PRELOAD ERROR CODE
	JZ	BBLGETD	* DONE DUE TO TIMEOUT ERROR
	JMP	BBLGFP	* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLGFRD EQU *
	IN	BBLDAT		* GET BYTE FROM BUBBLE -> BITBUCKET
	DCR	L		* DECREMENT REMAINDER COUNTER
	JNZ	BBLGFP	* AND READ FROM FIFO UNTIL LAST DONE


BBLGETD EQU *
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  CALL NEWLINE			* UNCOMMENT FOR VERBOSE
	POP	B		* RESTORE BC
	POP	D		* RESTORE DE
	RET			* RETURN TO CALL

* ********************************************************************
* **************  BUBBLE PUT DATA FROM RAM INTO BUBBLE  *******************
*   NAME: BBLPUT
*   FUNCTION: WRITES MEMORY DATA TO THE BUBBLE
*   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: NONE
*   USER IO: NONE
*   DESTROYS: A,H,L, F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	LOAD LSB OF BLOCK LENGTH IN BBLRL
* 	LOAD LSB OF BUBBLE ADDRESS INTO BARL
* 	LOAD MSB OF BUBBLE ADDRESS INTO BARH
* 	LOAD NUMBER OF BYTES TO TRANSFER INTO HL REGISTER PAIR
* 	LOAD STARTING MEMORY ADDRESS OF DATA TO BE SAVED INTO DE REGISTER PAIR
* 	CALL BBLWRIT
* * ********************************************************************
BBLPUT EQU *
*  CALL NEWLINE			* UNCOMMENT FOR VERBOSE
*  MVI A,'W'			* UNCOMMENT FOR VERBOSE
*  CALL CO			* UNCOMMENT FOR VERBOSE
	PUSH	D		* SAVE NUMBER OF BYTES
	PUSH	B		* USED IN THIS ROUTINE FOR TIMEOUT COUNTER
	LXI	B,0FFFFH	* LOAD TIMEOUT COUNTER
	MVI	A,13H		* LOAD WRITE BUBBLE MEMORY DATA COMMAND
	OUT	BBLCS		* SEND COMMAND TO 7220 COMMAND REGISTER
BBLPUTB EQU *
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SEE IF ANY B BITS SET
	ORA	C		* SEE IF ANY C BITS SET
	MVI	A,0EAH		* PRELOAD ERROR CODE
	JZ	BBLPUTD	* IF ZERO, DONE BECAUSE OF TIMEOUT ERROR
	IN	BBLCS		* OTHERWISE, GET STATUS REGISTER
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLPUTB	* WAIT UNTIL BUSY GOES INDICATING RECEIPT OF COMMAND

BBLPUTP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO READY BIT INTO CARRY
	JC	BBLPUTW	* ROOM IN FIFO, SO ADD A BYTE
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EBH		* PRELOAD ERROR CODE
	JNC	BBLPUTD	* NOT BUSY, SO DONE BUT WITH ERROR

	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0ECH		* PRELOAD ERROR CODE
	JZ	BBLPUTD	* DONE DUE TO TIMEOUT ERROR
	JMP	BBLPUTP	* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLPUTW EQU *

	LDAX	D		* LOAD DATA FROM DE REGISTER ADDRESS
	OUT	BBLDAT		* SEND TO BUBBLE FIFO
	INX	D		* INCREMENT TO NEXT MEMORY ADDRESS

	DCX	H		* DECREMENT DATA BYTE COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* ADD ANY BITS THAT ARE SET IN H
	ORA	L		* AND THEN ANY BITS SET IN L
	JNZ	BBLPUTP	* LOOP UNTIL ALL BYTES ARE DONE OR ERROR OCCURS

	LDA	BBLPUC		* GET THE PAGE UNUSED COUNT
	MOV	L,A		* PUT INTO L

*                                 NOW NEED TO FILL UP THE REMAINDER OF THE PAGE
	ORA	A		* SEE IF THERE IS A REMAINDER
 	JZ	BBLPUTD	* NOPE, ALL DONE

BBLPFP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLPFW	* ROOM IN FIFO, SO ADD A BYTE
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EDH		* PRELOAD ERROR CODE
	JNC	BBLPUTD	* NOT BUSY SO....DONE I GUESS?
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0EEH		* PRELOAD ERROR CODE
	JZ	BBLPUTD	* DONE DUE TO TIMEOUT ERROR
	JMP	BBLPFP	* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLPFW EQU *
 	MOV	A,L		* LOAD REMAINDER COUNTER, SAVE AS DATA BYTE (DIAGNOSTIC)
	OUT	BBLDAT		* SEND TO BUBBLE FIFO
	DCR	L		* DECREMENT REMAINDER COUNTER
	JNZ	BBLPFP	* AND OUTPUT NEXT FILLER UNTIL DONE

BBLPUTD EQU *
	IN	BBLCS		* GET BUBBLE STATUS
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  CALL NEWLINE			* UNCOMMENT FOR VERBOSE
	POP	B		* RESTORE BC
	POP	D		* RESTORE DE
	RET			* RETURN TO CALL

* ********************************************************************
* **************  BUBBLE READ DATA FROM BUBBLE INTO RAM  *******************
*   NAME: BBLREAD
*   FUNCTION: READS BUBBLE DATA AND PUTS INTO RAM
*   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR. 40H OR 42H = SUCCESS
*   USER IO: NONE
*   DESTROYS: A,F/F'S
*   CALLS: BBLFFR,BBL_LPR,BBL_BYTES,BBLPUT
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	BARL <- LSB OF BUBBLE ADDRESS
* 	BARH <- MSB OF BUBBLE ADDRESS
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	DE <- STARTING RAM ADDRESS OF DESTINATION
* 	CALL BBLREAD
* * ********************************************************************
BBLREAD EQU 	*
	PUSH	D		* SAVE DE
	PUSH	H		* SAVE HL
	CALL	BBLABRT	* ABORT ANY COMMANDS BEING PROCESSED
	CALL	BBLFFR		* CALL BUBBLE FIFO RESET ROUTINE
	XRI	BSROCCM	* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLRDDN	* IF DIDN'T FINSIH ABORT, WE ARE DONE WITH ERROR
	CALL	BBLCLBL	* CALCULATE AND LOAD BLOCK LENGTH TO BUFFER
	MVI	A,BBLEV	* GET ENABLE BYTE VALUE
	STA	BBLER		* BUBBLE ENABLE VALUE  -> BUFFER
	CALL	BBLPRL		* CALL LOAD PARAMETRIC REGISTER
	CALL	BBLGET		* READ BUBBLE DATA
	LXI	H,0FFFFH	* INITIALIZE TIMEOUT COUNTER
BBLRDLP EQU	*
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLRDDN	* IF NOT BUSY, RETURN
	DCX	H		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* SET ANY BITS IN H THAT ARE SET
	ORA	L		* DO THE SAME FOR ANY BITS IN L
	JNZ	BBLRDLP	* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLRDDN EQU	*
	POP	H		* RESTORE HL
	POP	D		* RESTORE DE
	IN	BBLCS		* GET BUBBLE STATUS
	RET			* RETURN TO CALL


* ********************************************************************
* **************  BUBBLE WRITE DATA FROM RAM INTO BUBBLE  *******************
*   NAME: BBLWRIT
*   FUNCTION: WRITES MEMORY DATA TO THE BUBBLE
*   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR. 40H OR 42H = SUCCESS
*   USER IO: NONE
*   DESTROYS: A,F/F'S
*   CALLS: BBLFFR,BBL_LPR,BBL_BYTES,BBLPUT
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	BARL <- LSB OF BUBBLE ADDRESS
* 	BARH <- MSB OF BUBBLE ADDRESS
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	DE <- STARTING MEMORY ADDRESS OF SOURCE DATA
* 	CALL BBLWRIT
* * ********************************************************************
BBLWRIT EQU	*
	PUSH	H		* SAVE HL
	CALL	BBLABRT	* ABORT ANY COMMANDS BEING PROCESSED
	CALL	BBLFFR		* CALL BUBBLE FIFO RESET ROUTINE
	XRI	BSROCCM	* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLWRDN	* IF DIDN'T FINISH ABORT, WE ARE DONE BUT WITH ERROR
	CALL	BBLCLBL	* CALCULATE AND LOAD BLOCK LENGTH TO BUFFER
	MVI	A,BBLEV	* GET ENABLE BYTE VALUE
	STA	BBLER		* BUBBLE ENABLE VALUE  -> BUFFER
	CALL	BBLPRL		* CALL LOAD PARAMETRIC REGISTER
	CALL	BBLPUT		* WRITE BUBBLE DATA
	LXI	H,0FFFFH	* INITIALIZE TIMEOUT COUNTER
BBLWRLP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST FOR BUSY BIT
	JNC	BBLWRDN	* IF NOT BUSY, CLEAN UP AND RETURN
	DCX	H		* IF STILL BUSY, DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* SET ANY BITS IN H THAT ARE SET
	ORA	L		* DO THE SAME FOR ANY BITS IN L
	JNZ	BBLWRLP	* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLWRDN EQU	*
	POP	H		* RESTORE HL
	IN	BBLCS		* GET BUBBLE STATUS
	RET			* RETURN TO CALL


* ********************************************************************
* ***********  BUBBLE CALCULATE AND LOAD BLOCK LENGTH  ***************
*   NAME: BBLCLBL
*   FUNCTION: CALCULATES THE BLOCK LENGTH AND LOADS INTO BUFFER FOR REGISTER LOAD
*   INPUTS: HL=NUMBER OF BYTES TO READ OR WRITE
*   OUTPUTS: BLOCK LENGTH LOADED INTO LSB REGISTER
*   USER IO: NONE
*   DESTROYS: A,F/F'S
*   CALLS:
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	RESULT: CALCULATED BLOCK LENGTH -> BBLRL
* * ********************************************************************
BBLCLBL  EQU	*
	PUSH	B		* B=# OF PAGES, C=NUMBER OF BYTES LEFT ON THIS PAGE
	PUSH	H		* SAVE THE ORIGINAL COUNT
*  CALL	SENDHL			* UNCOMMENT FOR VERBOSE
	MVI	C,BBLBPP	* BUBBLE BYTES PER PAGE VALUE
	MVI	B,01D		* STARTING VALUE = 1 PAGE


BBLCLLP EQU *
	DCR	C
	JP	BBLCL1	* IF BYTES LEFT ON THIS PAGE, CONTINUE
	MVI	C,BBLBPP-1	* RELOAD BYTES PER PAGE
	INR	B		* SPILL OVER INTO ANOTHER PAGE SO INCREASE PAGE COUNT

BBLCL1 EQU	*
	DCX	H		* DECREMENT NUMBER OF BYTES LEFT
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* SEE IF BYTE COUNT IS ZERO BY ADDING BITS TO ACCUMULATOR
	ORA	L		* FIRST H THEN L
	JNZ	BBLCLLP	* NOT ZERO, DO ANOTHER BYTE



*  MVI A,'='			* UNCOMMENT FOR VERBOSE
*  CALL CO			* UNCOMMENT FOR VERBOSE
	MOV	A,B		* MOVE NUMBER OF PAGES (BLOCKS) NEEDED INTO A
	STA	BBLRL		* NUMBER OF BLOCKS USED ROUNDED UP -> BUFFER
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  MVI A,'r'			* UNCOMMENT FOR VERBOSE
*  CALL CO			* UNCOMMENT FOR VERBOSE
	MOV	A,C
	STA	BBLPUC		* NUMBER OF EMPTY PLACES LEFT IN PAGE  -> BUFFER
*  CALL	HO			* UNCOMMENT FOR VERBOSE
*  CALL	NEWLINE			* UNCOMMENT FOR VERBOSE
	POP	H
	POP	B
 	RET


* ********************************************************************
* *********************  DUMP MEMORY BRANCH  *************************
*   NAME: CMDD
*   FUNCTION: DISPLAYS BLOCK OF MEMORY
*   INPUTS: NONE
*   OUTPUTS: NONE
*   USER IO: REQUESTS STARTING AND ENDING ADDRESSES, DISPLAYS MEM VALUES BETWEEN
*   DESTROYS: A. F/F'S,BC,DE,HL
*   CALLS: HO, GETHEXW, SENDSTR, SENDHL, NEWLINE, SENDDE, CO
*   DESCRIPTION:THE USER IS ASKED FOR THE STARTING AND ENDING MEMORY ADDRESSES
*      THE PROGRAM THEN DISPLAYS THE VALUES OF MEMORY
* * ********************************************************************
CMDD	EQU	*
	LXI	H,CMDDSM	* MSG TO USER FOR START ADDRESS
	CALL	SENDSTR
	CALL	GETHEXW	* PUT STARTING ADDRESS INTO HL
	XCHG			* MOVE STARTING ADDRESS INTO DE
	LXI	H,CMDDEM	* ASK FOR ENDING ADDRESS
	CALL	SENDSTR
	CALL	GETHEXW	* PUT ENDING ADDRESS INTO HL
	XCHG			* SWAP SO START IN HL, END IN DE
	CALL	NEWLINE
 	CALL	SENDHL		* REPEAT BACK TO USER OUR UNDERSTANDING OF ADDRESSES
 	MVI	A,' '
 	CALL	CO
 	MVI	A,'T'
 	CALL	CO
 	MVI	A,'O'
 	CALL	CO
 	MVI	A,' '
 	CALL	CO
 	CALL	SENDDE
 	CALL	NEWLINE

CMDDLN EQU	*
	PUSH	H		* SAVE HL FOR LATER
	CALL	SENDHL		* SEND ADDRESS
	MVI	A,':'
	CALL	CO
	MVI	A,' '
	CALL	CO
	MVI	B,0FH+1		* NUMBER OF LOCATIONS PER LINE

CMDDCHR EQU	*
	MOV	A,M		* GET THE MEMORY VALUE
	CALL	HO		* DISPLAY M
	MOV	A,H		* SEE IF WE ARE DONE:
	CMP	D		* SEE HIGH BYTE IS THE SAME
	JNZ	CMDDNM	* IF NOT EQUAL, CONTINUE LOOP
	MOV	A,L
	CMP	E		* IF HIGH BYTE SAME, CHECK LOW BYTE
	JZ	CMDDHD	* DISPLAYED ENDING ADDRESS, WE ARE DONE


CMDDNM EQU *
	MVI	A,SPACE		* PUT A SPACE BETWEEN VALUES
	CALL	CO
	INX	H		* NEXT LOCATION
	DCR	B		* ONE LESS FOR THIS LINE
	JNZ	CMDDCHR	* MORE TO DO ON THIS LINE

CMDDHD EQU *
*                                 LINE IS DONE. LETS REDISPLAY AS ASCII
	POP	B		* WAS PUSHED AS H, GET BACK AS THE STARTING ADDRESS FOR LINE WE JUST DID
	PUSH	H		* SAVE OUR PLACE FOR NEXT LOCATION TO OUTPUT
	MOV	H,B		* M IS NOW BACK AT THE BEGINNING OF THE LINE
	MOV	L,C

	MVI	B,0FH+1		* NUMBER OF LOCATIONS PER LINE
	MVI	A,SPACE
	CALL	CO

CMDDAS EQU *
	MOV	A,M		* GET CHARACTER AGAIN
	CPI	SPACE		* LESS THAN SPACE
	JC	CMDDS4D	* NONDISPLAYABLE CHARACTER.  TO SMALL
	CPI	'~'
	JC	CMDDAS1	* DISPLAYABLE SO CONTINUE
CMDDS4D EQU *
	MVI	A,'.'

CMDDAS1 EQU *
	CALL	CO

CMDDNA EQU *
	MOV	A,H		* SEE IF WE ARE DONE:
	CMP	D		* SEE HIGH BYTE IS THE SAME
	JNZ	CMDDAC	* IF NOT EQUAL, CONTINUE LOOP
	MOV	A,L
	CMP	E		* IF HIGH BYTE SAME, CHECK LOW BYTE
	JZ	CMDDDN	* DISPLAYED ENDING ADDRESS, WE ARE DONE

CMDDAC EQU *
	DCR	B
	INX	H		* POINT TO NEXT
	JNZ	CMDDAS
*                                 WE ARE DONE WITH ASCII
	POP	H		* RESTORE LAST ADDRESS OUTPUT
	CALL	NEWLINE
	JMP	CMDDLN	* DO NEXT LINE

CMDDDN EQU	*		* DONE DISPLAYING MEMORY
	POP	H		* CLEAN UP STACK THE STACK
	CALL	NEWLINE
	JMP	CMDLOOP		* DONE HERE, RETURN TO COMMAND PROCESSOR

CMDDU	DB	'D -- (D)UMP MEMORY BETWEEN START AND END ADDRESSES',212Q
CMDDSM	DB	'HEX STARTING ADDRESS? (XXXX)',212Q
CMDDEM	DB	LF,'HEX ENDING ADDRESS? (XXXX)',212Q

INPBUF 	DS	68D
BUR	DS	1	* BUBBLE UTILITY REGISTER
BBLRL	DS	1	* BUBBLE BLOCK LENGTH REGISTER LSB
BBLER	DS	1	* BUBBLE ENABLE REGISTER
BAR	EQU	*
BARL	DS	1	* BUBBLE ADDRESS REGISTER LSB
BARH	DS	1	* BUBBLE ADDRESS REGISTER MSB
BBLPUC	DS	1	* BUBBLE PAGE UNUSED COUNT (BYTES)

SPACE	EQU	' '
BS	EQU	08H

PROMPT	EQU	*
HO	EQU	*
CI	EQU	*
CO	EQU	*
SENDSPC EQU	*
SENDSTR EQU	*
GETHEXW EQU	*
SENDDE	EQU	*
SENDHL	EQU	*
NEWLINE EQU	*
TOHEX	EQU	*
BOB	EQU	*

BANMSG	DB	LF,'Hello World',212Q

	END	ENTRY
