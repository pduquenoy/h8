* BASED ON SBC-85 BUBBLE MEMORY ROUTINES BY CRAIG ANDREWS, 2020
* COPYRIGHT 2019 (C) OF CRAIG ANDREWS ALL RIGHTS RESERVED

* MINIMIZED BDREAD FOR RO DRIVER

BDREAD	EQU     *

	MOV	A,B
	ORA	C
	RZ				* Asking to read 0 bytes so just return

	PUSH	B			* SAVE BC
	PUSH	D			* SAVE DE
	PUSH	H			* SAVE HL
	CALL	STOBLK
	MOV	H,B			* MOVE BYTE COUNT FROM BC ...
	MOV	L,C			* ... TO HL
	CALL	BBLREAD
	POP	H			* RESTORE HL
	POP	D			* RESTORE DE
	POP	B			* RESTORE BC
	ANA	A
	RET

**********************************************************

STOBLK	EQU	*
	PUSH	B
	MOV	A,L			* START WITH LOW BYTE OF SECNUM
	RLC				* MULTIPLY BY...
	RLC				* ...FOUR
	ANI	0FCH			* STRIP OFF THE LAST TWO BITS
	STA	BARL			

	MOV	A,L			* START WITH LOW BYTE OF SECNUM
	RLC				* MULTIPLY BY FOUR...
	RLC				* ... ROTATING TOP 2 BITS TO LOWER
	ANI	003H			* KEEP ONLY THE LAST TWO BITS
	MOV	B,A			* B = (SECNO>>6)
	
	MOV	A,H			* START WITH HIGH BYTE OF SECNUM
	RLC				* MULTIPLY BY...
	RLC				* ...FOUR
	ANI	01CH			* MASK BITS 11100
	ORA	B			* OR IN THE LOWER 2 BITS
	STA	BARH
	POP	B
	RET

* SPACE IS A PREMIUM, SO WE REPRODUCE SOME BBLLIB CODE BELOW, WITH
* TIMEOUTS AND STUFF RIPPED OUT OF IT, TO MAKE IT FIT.

* ********************************************************************
* **************  BUBBLE GET DATA AND SAVE INTO RAM  *******************
*   NAME: BBLGET
*   FUNCTION: READS BUBBLE DATA AND PUTS INTO RAM
*   INPUTS: DE=STARTING ADDRESS OF RAM, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: NONE
*   USER IO: NONE
*   DESTROYS: A,H,L, F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	LOAD LSB OF BLOCK LENGTH IN BBLRL
* 	LOAD LSB OF BUBBLE ADDRESS INTO BARL
* 	LOAD MSB OF BUBBLE ADDRESS INTO BARH
* 	LOAD NUMBER OF BYTES TO TRANSFER INTO HL REGISTER PAIR
* 	LOAD STARTING ADDRESS OF RAM TO SAVE DATA INTO DE REGISTER PAIR
* 	CALL BBLREAD
* * ********************************************************************
BBLGET EQU *
	PUSH	D		* SAVE NUMBER OF BYTES
	PUSH	B		* USED IN THIS ROUTINE
*	LXI	B,0FFFFH	* LOAD TIMEOUT COUNTER
	MVI	A,12H		* LOAD READ BUBBLE MEMORY DATA COMMAND
	OUT	BBLCS		* SEND COMMAND TO 7220 COMMAND REGISTER
BBLGETB EQU *
*	DCX	B		* DECREMENT TIMEOUT COUNTER
*	XRA	A		* CLEAR ACCUMULATOR
*	ORA	B		* SEE IF ANY B BITS SET
*	ORA	C		* SEE IF ANY C BITS SET
*	MVI	A,0EAH		* PRELOAD ERROR CODE
*	JZ	BBLGETD		* IF ZERO, DONE BECAUSE OF TIMEOUT ERROR
	IN	BBLCS		* OTHERWISE, GET STATUS REGISTER
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLGETB		* LOOP UNTIL BUBBLE SETS BUSY INDICATING RECEIPT

BBLGETP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLGETR		* SOMETHING IN FIFO, SO READ BYTE

*	IN	BBLCS		* GET BUBBLE STATUS
*	RLC			* TEST BUSY BIT
*	MVI	A,0EBH		* PRELOAD ERROR B JUST IN CASE
*	JNC	BBLGETD		* NOT BUSY, SO DONE BUT WITH ERROR

*	DCX	B		* DECREMENT TIMEOUT COUNTER
*	XRA	A		* CLEAR ACCUMULATOR
*	ORA	B		* SET ANY BITS IN B THAT ARE SET
*	ORA	C		* DO THE SAME FOR ANY BITS IN C
*	MVI	A,0ECH		* PRELOAD ERROR C JUST IN CASE
*	JZ	BBLGETD		* DONE DUE TO TIMEOUT ERROR
	JMP	BBLGETP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLGETR EQU *

	IN	BBLDAT		* READ BYTE FROM BUBBLE
	STAX	D		* MOVE DATA BYTE INTO DE REGISTER ADDRESS
	INX	D		* INCREMENT TO NEXT MEMORY ADDRESS

	DCX	H		* DECREMENT DATA BYTE COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* ADD ANY BITS THAT ARE SET IN H
	ORA	L		* AND THEN ANY BITS SET IN L
	JNZ	BBLGETP		* LOOP UNTIL ALL BYTES ARE DONE OR ERROR OCCURS

*                                 NOW FLUSH OUT THE REMAINDER OF THE PAGE FROM FIFO
	LDA	BBLPUC		* GET THE PAGE UNUSED COUNT
	MOV	L,A		* PUT INTO L
	ORA	A		* SEE IF THERE IS A REMAINDER
 	JZ	BBLGETD		* NOPE, ALL DONE


BBLGFP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLGFRD		* SOMETHING IN FIFO, GET IT
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EDH		* PRELOAD ERROR D
	JNC	BBLGETD		* NOT BUSY SO....DONE I GUESS?
*	DCX	B		* DECREMENT TIMEOUT COUNTER
*	XRA	A		* CLEAR ACCUMULATOR
*	ORA	B		* SET ANY BITS IN B THAT ARE SET
*	ORA	C		* DO THE SAME FOR ANY BITS IN C
*	MVI	A,0EEH		* PRELOAD ERROR CODE
*	JZ	BBLGETD		* DONE DUE TO TIMEOUT ERROR
	JMP	BBLGFP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLGFRD EQU *
	IN	BBLDAT		* GET BYTE FROM BUBBLE -> BITBUCKET
	DCR	L		* DECREMENT REMAINDER COUNTER
	JNZ	BBLGFP		* AND READ FROM FIFO UNTIL LAST DONE


BBLGETD EQU *
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  CALL NEWLINE			* UNCOMMENT FOR VERBOSE
	POP	B		* RESTORE BC
	POP	D		* RESTORE DE
	RET			* RETURN TO CALL

* * ********************************************************************
BBLREAD EQU 	*
	DI			* DISABLE INTERRUPTS
*	PUSH	D		* SAVE DE
*	PUSH	H		* SAVE HL
	CALL	BBLABRT		* ABORT ANY COMMANDS BEING PROCESSED
	CALL	BBLFFR		* CALL BUBBLE FIFO RESET ROUTINE
	XRI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLRDDN		* IF DIDN'T FINSIH ABORT, WE ARE DONE WITH ERROR
	CALL	BBLCLBL		* CALCULATE AND LOAD BLOCK LENGTH TO BUFFER
	MVI	A,BBLEV		* GET ENABLE BYTE VALUE
	STA	BBLER		* BUBBLE ENABLE VALUE  -> BUFFER
	CALL	BBLPRL		* CALL LOAD PARAMETRIC REGISTER
	CALL	BBLGET		* READ BUBBLE DATA
*	LXI	H,0FFFFH	* INITIALIZE TIMEOUT COUNTER
BBLRDLP EQU	*
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLRDDN		* IF NOT BUSY, RETURN
*	DCX	H		* DECREMENT TIMEOUT COUNTER
*	XRA	A		* CLEAR ACCUMULATOR
*	ORA	H		* SET ANY BITS IN H THAT ARE SET
*	ORA	L		* DO THE SAME FOR ANY BITS IN L
*	JNZ	BBLRDLP		* HAVE NOT TIMED OUT, SO LOOP AGAIN
	JMP	BBLRDLP

BBLRDDN EQU	*
*	POP	H		* RESTORE HL
*	POP	D		* RESTORE DE
	IN	BBLCS		* GET BUBBLE STATUS
	EI			* ENABLE INTERRUPTS
	RET			* RETURN TO CALL

