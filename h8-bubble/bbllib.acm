* BASED ON SBC-85 BUBBLE MEMORY ROUTINES BY CRAIG ANDREWS, 2020
* COPYRIGHT 2019 (C) OF CRAIG ANDREWS ALL RIGHTS RESERVED

* The following are bubble I/O routines
* TO USE THE BUBBLE ROUTINES:
* THE BUBBLE MUST FIRST BE INITIALIZED BY CALLING BBLINIT BEFORE ANYTHING ELSE.
* BBLINIT WILL CONFIGURE THE RAM BUFFER TO THEIR DEFAULT VALUES
*
* AFTER INITIALIZED,
* BBLWRIT IS USED TO COPY FROM MEMORY INTO THE BUBBLE
* BBLREAD IS USED TO COPY FROM THE BUBBLE AND STORE INTO RAM
*
* BEFORE BBLWRIT OR BBLREAD ARE CALLED, THE FOLLOWING PARAMETRIC VALUES
* MUST BE STORED TO THE CORRESPONDING BUFFERS IN RAM OR IN THE REGISTERS
* 	BARL	BUBBLE ADDRESS REGISTER LSB
* 	BARH	BUBBLE ADDRESS REGISTER MSB
* 	REGISTER DE = STARTING MEMORY ADDRESS OF DATA TRANSFER
* 	REGISTER HL = NUMBER OF BYTES TO BE TRANSFERRED
* AFTER EITHER READ OR WRITE REGISTER A WILL CONTAIN THE RESULTING 7220 STATUS




* ********************************************************************
* **************  BUBBLE ABORT  *******************
*   NAME: BBLABRT
*   FUNCTION:SEND THE ABORT COMMAND TO THE 7220
*   INPUTS: NONE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:SEND THE ABORT COMMAND TO 7220
* * ********************************************************************
BBLABRT EQU 	*
	CALL BBLAB1
	CALL BBLAB1
	RET

BBLAB1	EQU	*
*	MVI	A,'A'		* UNCOMMENT FOR VERBOSE
*	CALL	CO		* UNCOMMENT FOR VERBOSE
	PUSH	D		* DE USED FOR TIMEOUT COUNTER, SAVE
	LXI	D,0FFFFH	* LOAD COUNTER START VALUE
	MVI	A,19H		* ABORT COMMAND FOR 7220
	OUT	BBLCS		* SEND TO COMMAND REGISTER
BBLABBS EQU *
	IN	BBLCS		* GET BUBBLE STATUS REGISTER
	RLC			* TEST BUSY BIT =1
	JC	BBLABP		*  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	D		*  ADD ANY SET BITS IN D
	ORA	E		*  THEN SAME FOR E
	JNZ	BBLABBS		* TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E1H		* RETURN WITH ERROR 1
	JMP	BBLABDN		* DONE, BUT WITH TIMEOUT ERROR

BBLABP EQU *
	IN	BBLCS		* READ STATUS REGISTER
	CPI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLABDN		* DONE WITH SUCCESS
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR A
	ORA	D		*  ADD ANY SET BETS IN D
	ORA	E		*  ADD ANY SET BITS IN E
	JNZ	BBLABP		* IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E2H		* RETURN WITH ERROR 2

BBLABDN EQU *
	POP	D
*	CALL	HO			* UNCOMMENT FOR VERBOSE
*	CALL	NEWLINE			* UNCOMMENT FOR VERBOSE

	RET			* RETURN

* ********************************************************************
* **************  BUBBLE FIFO RESET  *******************
*   NAME: BBLFFR
*   FUNCTION:SEND THE FIFO RESET COMMAND TO THE 7220
*   INPUTS: NONE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:SEND THE FIFO RESET COMMAND TO THE 7220 AND WAIT FOR
* 	THE OP-COMPLETE FLAG OR (BUSY OR COMPLETE) TIMEOUT, WHATEVER COMES FIRST
* * ********************************************************************
BBLFFR EQU *
*  MVI	A,'F'			* UNCOMMENT FOR VERBOSE
*  CALL	CO
	PUSH	D		* DE USED FOR TIMEOUT COUNTER, SAVE
	LXI	D,0FFFFH	* LOAD COUNTER START VALUE
	MVI	A,1DH		* FIFO RESET COMMAND FOR 7220
	OUT	BBLCS		* SEND TO COMMAND REGISTER
BBLFFRB EQU	*
	IN	BBLCS		* GET BUBBLE STATUS REGISTER
	RLC			* TEST BUSY BIT =1
	JC	BBLFFRP		*  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	D		*  ADD ANY SET BITS IN D
	ORA	E		*  THEN SAME FOR E
	JNZ	BBLFFRB		* TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E3H		* RETURN WITH ERROR 3
	JMP	BBLFFRD		* DONE, BUT WITH TIMEOUT ERROR

BBLFFRP EQU *
	IN	BBLCS		* READ STATUS REGISTER
	CPI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLFFRD		* DONE WITH SUCCESS
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR A
	ORA	D		*  ADD ANY SET BETS IN D
	ORA	E		*  ADD ANY SET BITS IN E
	JNZ	BBLFFRP		* IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E4H		* RETURN WITH ERROR 4 IN ACCUMULATOR

BBLFFRD EQU *
	POP	D
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  CALL NEWLINE
	RET			* RETURN


* ********************************************************************
* **************  BUBBLE INITIALIZE  *******************
*   NAME: BBLINIT
*   FUNCTION:INITIALIZES BUBBLE MEMORY SYSTEM
*   INPUTS: NONE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: BBLABRT, BBLPRL
*   DESCRIPTION:THIS COMMAND IS REQURIED AFTER POWERUP AND MUST PRECEED
* 	ALL OTHER COMMANDS. IT FIRST LOADS THE RAM PARAMETER BUFFERS WITH
* 	THE REQUIRED DEFAULT VALUES FOR INITIALIZATION, THEN ABORTS ANY
* 	EXISTING BUBBLE COMMAND THAT MAY BE PROCESSING, AND THEN INITIALIZES
* 	THE BUBBLE.  IT WILL RETURN IF ANYTHING RESULTS IN A TIMEOUT OR ANY
* 	STATUS OTHER THAN AN OPERATION COMPLETE STATUS.
* * ********************************************************************
BBLINIT EQU *
*  MVI	A,'I'			* UNCOMMENT FOR VERBOSE
*  CALL	CO
	PUSH	D		* DE USED FOR TIMEOUT COUNTER, SAVE

	MVI	A,BBLRLV	* GET DEFAULT VALUE FOR BLOCK LENGTH LSB
	STA	BBLRL		* BUBBLE BLOCK LENGTH LSB -> BUFFER
	MVI	A,BBLEV		* GET ENABLE BYTE
	STA	BBLER		* BUBBLE ENABLE -> BUFFER
	MVI	A,BARLV		* GET DEFAULT BUBBLE ADDRESS LSB
	STA	BARL		* BUBBLE ADDRESS LSB-> BUFFER
	MVI	A,BARHV		* GET DEFAULT BUBBLE ADDRESS MSB
	STA	BARH		* BUBBLE ADDRESS MSB-> BUFFER
	CALL	BBLABRT		* ABORT ANY COMMANDS BEING PROCESSED
	CPI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLINID		* IF DIDN'T FINSIH ABORT, WE ARE DONE WITH ERROR
	CALL	BBLPRL		* PARAMETRIC REGISTER LOAD
	LXI	D,0FFFFH	* LOAD TIMEOUT LOOP COUNTER
	MVI	A,11H		* LOAD INITIALIZE BUBBLE COMMAND
	OUT	BBLCS		* SEND INITIALIZE COMMAND TO BUBBLE

BBLINIB EQU *
	IN	BBLCS		* GET BUBBLE STATUS REGISTER
	RLC			* TEST BUSY BIT =1
	JC	BBLINIP		*  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	D		*  ADD ANY SET BITS IN D
	ORA	E		*  THEN SAME FOR E
	JNZ	BBLINIB		* TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E5H		* RETURN WITH ERROR 5
	JMP	BBLINID		* DONE, BUT WITH TIMEOUT ERROR

BBLINIP EQU *
	IN	BBLCS		* READ STATUS REGISTER
	CPI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLINID		* DONE WITH SUCCESS
	DCX	D		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR A
	ORA	D		*  ADD ANY SET BETS IN D
	ORA	E		*  ADD ANY SET BITS IN E
	JNZ	BBLINIP		* IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E6H

BBLINID EQU *

	POP	D
*  CALL	HO			* UNCOMMENT FOR VERBOSE
*  CALL	NEWLINE
	RET			* RETURN


* ********************************************************************
* **************  BUBBLE PARAMETRIC REGISTER LOAD  *******************
*   NAME: BBLPRL
*   FUNCTION: FILLS BUBBLE PARAMETRIC REGISTERS WITH VALUES IN RAM BUFFER
*   INPUTS: NONE
*   OUTPUTS: NONE
*   USER IO: NONE
*   DESTROYS: A. F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:SENDS THE PARAMETRIC REGISTER VALUES HELD IN RESERVED RAM
* 	LOCATIONS TO BUBBLE 7220. ENDS WITH PARAMETRIC REGISTER ADDRESS POINTING
* 	TO 7220 FIFO
* 	THE ENABLE REGISTER AND BLOCK LENGTH MSB ARE HARD CODED
* * ********************************************************************
BBLPRL EQU *
*  MVI A,'P'			* UNCOMMENT FOR VERBOSE
*  CALL CO
	MVI	A,BBLRLA	* GET STARTING REGISTER NUMBER
	OUT	BBLCS		* SET 7220 REGISTER POINTER TO BLR LSB
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  mvi a,' '
*  CALL CO
*  MVI A,'b'
*  CALL CO
	LDA	BBLRL		* GET BLOCK LENGTH LSB VALUE FROM RAM BUFFER
	OUT	BBLDAT		* LOAD IN BLOCK LENGTH LSB REGISTER
*  CALL HO			* UNCOMMENT FOR VERBOSE
	MVI	A,BBLRHV	* GET BLOCK LENGTH MSB VALUE
	OUT	BBLDAT		* LOAD IN BLOCK LENGTH MSB REGISTER
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  mvi a,' '
*  CALL CO			* UNCOMMENT FOR VERBOSE
*  MVI A,'e'
*  CALL CO			* UNCOMMENT FOR VERBOSE
	LDA	BBLER		* GET ENABLE REGISTER VALUE
	OUT	BBLDAT		* LOAD IN BUBBLE ENABLE REGISTER
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  mvi a,' '
*  CALL CO			* UNCOMMENT FOR VERBOSE
*  MVI A,'a'
*  CALL CO
	LDA	BARL		* GET ADDRESS LSB
	OUT	BBLDAT		* LOAD IN BUBBLE AR_L REGISTER
*  CALL HO
	LDA	BARH		* GET ADDRESS MSB
	OUT	BBLDAT		* LOAD INTO BUBBLE ADDRESS MSB REGISTER
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  mvi a,' '
*  CALL CO
*  MVI	A,'s'
*  CALL	CO			* UNCOMMENT FOR VERBOSE

	IN	BBLCS		* GET STATUS BEFORE RETURN
*  CALL	HO			* UNCOMMENT FOR VERBOSE

	RET			* DONE LOADING 7220 REGISTERS, RETURN



* ********************************************************************
* **************  BUBBLE GET DATA AND SAVE INTO RAM  *******************
*   NAME: BBLGET
*   FUNCTION: READS BUBBLE DATA AND PUTS INTO RAM
*   INPUTS: DE=STARTING ADDRESS OF RAM, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: NONE
*   USER IO: NONE
*   DESTROYS: A,H,L, F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	LOAD LSB OF BLOCK LENGTH IN BBLRL
* 	LOAD LSB OF BUBBLE ADDRESS INTO BARL
* 	LOAD MSB OF BUBBLE ADDRESS INTO BARH
* 	LOAD NUMBER OF BYTES TO TRANSFER INTO HL REGISTER PAIR
* 	LOAD STARTING ADDRESS OF RAM TO SAVE DATA INTO DE REGISTER PAIR
* 	CALL BBLREAD
* * ********************************************************************
BBLGET EQU *
*  CALL	NEWLINE			* UNCOMMENT FOR VERBOSE
*  MVI	A,'R'			* UNCOMMENT FOR VERBOSE
*  CALL	CO			* UNCOMMENT FOR VERBOSE

	PUSH	D		* SAVE NUMBER OF BYTES
	PUSH	B		* USED IN THIS ROUTINE
	LXI	B,0FFFFH	* LOAD TIMEOUT COUNTER
	MVI	A,12H		* LOAD READ BUBBLE MEMORY DATA COMMAND
	OUT	BBLCS		* SEND COMMAND TO 7220 COMMAND REGISTER
BBLGETB EQU *
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SEE IF ANY B BITS SET
	ORA	C		* SEE IF ANY C BITS SET
	MVI	A,0EAH		* PRELOAD ERROR CODE
	JZ	BBLGETD		* IF ZERO, DONE BECAUSE OF TIMEOUT ERROR
	IN	BBLCS		* OTHERWISE, GET STATUS REGISTER
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLGETB		* LOOP UNTIL BUBBLE SETS BUSY INDICATING RECEIPT


BBLGETP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLGETR		* SOMETHING IN FIFO, SO READ BYTE

	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EBH		* PRELOAD ERROR B JUST IN CASE
	JNC	BBLGETD		* NOT BUSY, SO DONE BUT WITH ERROR

	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0ECH		* PRELOAD ERROR C JUST IN CASE
	JZ	BBLGETD		* DONE DUE TO TIMEOUT ERROR
	JMP	BBLGETP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLGETR EQU *

	IN	BBLDAT		* READ BYTE FROM BUBBLE
	STAX	D		* MOVE DATA BYTE INTO DE REGISTER ADDRESS
	INX	D		* INCREMENT TO NEXT MEMORY ADDRESS

	DCX	H		* DECREMENT DATA BYTE COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* ADD ANY BITS THAT ARE SET IN H
	ORA	L		* AND THEN ANY BITS SET IN L
	JNZ	BBLGETP		* LOOP UNTIL ALL BYTES ARE DONE OR ERROR OCCURS

*                                 NOW FLUSH OUT THE REMAINDER OF THE PAGE FROM FIFO
	LDA	BBLPUC		* GET THE PAGE UNUSED COUNT
	MOV	L,A		* PUT INTO L
	ORA	A		* SEE IF THERE IS A REMAINDER
 	JZ	BBLGETD	* NOPE, ALL DONE


BBLGFP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLGFRD		* SOMETHING IN FIFO, GET IT
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EDH		* PRELOAD ERROR D
	JNC	BBLGETD		* NOT BUSY SO....DONE I GUESS?
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0EEH		* PRELOAD ERROR CODE
	JZ	BBLGETD		* DONE DUE TO TIMEOUT ERROR
	JMP	BBLGFP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLGFRD EQU *
	IN	BBLDAT		* GET BYTE FROM BUBBLE -> BITBUCKET
	DCR	L		* DECREMENT REMAINDER COUNTER
	JNZ	BBLGFP		* AND READ FROM FIFO UNTIL LAST DONE


BBLGETD EQU *
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  CALL NEWLINE			* UNCOMMENT FOR VERBOSE
	POP	B		* RESTORE BC
	POP	D		* RESTORE DE
	RET			* RETURN TO CALL

* ********************************************************************
* **************  BUBBLE PUT DATA FROM RAM INTO BUBBLE  *******************
*   NAME: BBLPUT
*   FUNCTION: WRITES MEMORY DATA TO THE BUBBLE
*   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: NONE
*   USER IO: NONE
*   DESTROYS: A,H,L, F/F'S
*   CALLS: NOTHING
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	LOAD LSB OF BLOCK LENGTH IN BBLRL
* 	LOAD LSB OF BUBBLE ADDRESS INTO BARL
* 	LOAD MSB OF BUBBLE ADDRESS INTO BARH
* 	LOAD NUMBER OF BYTES TO TRANSFER INTO HL REGISTER PAIR
* 	LOAD STARTING MEMORY ADDRESS OF DATA TO BE SAVED INTO DE REGISTER PAIR
* 	CALL BBLWRIT
* * ********************************************************************
BBLPUT EQU *
*  CALL NEWLINE			* UNCOMMENT FOR VERBOSE
*  MVI A,'W'			* UNCOMMENT FOR VERBOSE
*  CALL CO			* UNCOMMENT FOR VERBOSE
	PUSH	D		* SAVE NUMBER OF BYTES
	PUSH	B		* USED IN THIS ROUTINE FOR TIMEOUT COUNTER
	LXI	B,0FFFFH	* LOAD TIMEOUT COUNTER
	MVI	A,13H		* LOAD WRITE BUBBLE MEMORY DATA COMMAND
	OUT	BBLCS		* SEND COMMAND TO 7220 COMMAND REGISTER
BBLPUTB EQU *
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SEE IF ANY B BITS SET
	ORA	C		* SEE IF ANY C BITS SET
	MVI	A,0EAH		* PRELOAD ERROR CODE
	JZ	BBLPUTD		* IF ZERO, DONE BECAUSE OF TIMEOUT ERROR
	IN	BBLCS		* OTHERWISE, GET STATUS REGISTER
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLPUTB		* WAIT UNTIL BUSY GOES INDICATING RECEIPT OF COMMAND

BBLPUTP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO READY BIT INTO CARRY
	JC	BBLPUTW		* ROOM IN FIFO, SO ADD A BYTE
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EBH		* PRELOAD ERROR CODE
	JNC	BBLPUTD		* NOT BUSY, SO DONE BUT WITH ERROR

	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0ECH		* PRELOAD ERROR CODE
	JZ	BBLPUTD		* DONE DUE TO TIMEOUT ERROR
	JMP	BBLPUTP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLPUTW EQU *

	LDAX	D		* LOAD DATA FROM DE REGISTER ADDRESS
	OUT	BBLDAT		* SEND TO BUBBLE FIFO
	INX	D		* INCREMENT TO NEXT MEMORY ADDRESS

	DCX	H		* DECREMENT DATA BYTE COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* ADD ANY BITS THAT ARE SET IN H
	ORA	L		* AND THEN ANY BITS SET IN L
	JNZ	BBLPUTP		* LOOP UNTIL ALL BYTES ARE DONE OR ERROR OCCURS

	LDA	BBLPUC		* GET THE PAGE UNUSED COUNT
	MOV	L,A		* PUT INTO L

*                                 NOW NEED TO FILL UP THE REMAINDER OF THE PAGE
	ORA	A		* SEE IF THERE IS A REMAINDER
 	JZ	BBLPUTD		* NOPE, ALL DONE

BBLPFP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RRC			* PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLPFW		* ROOM IN FIFO, SO ADD A BYTE
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST BUSY BIT
	MVI	A,0EDH		* PRELOAD ERROR CODE
	JNC	BBLPUTD		* NOT BUSY SO....DONE I GUESS?
	DCX	B		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	B		* SET ANY BITS IN B THAT ARE SET
	ORA	C		* DO THE SAME FOR ANY BITS IN C
	MVI	A,0EEH		* PRELOAD ERROR CODE
	JZ	BBLPUTD		* DONE DUE TO TIMEOUT ERROR
	JMP	BBLPFP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLPFW EQU *
 	MOV	A,L		* LOAD REMAINDER COUNTER, SAVE AS DATA BYTE (DIAGNOSTIC)
	OUT	BBLDAT		* SEND TO BUBBLE FIFO
	DCR	L		* DECREMENT REMAINDER COUNTER
	JNZ	BBLPFP		* AND OUTPUT NEXT FILLER UNTIL DONE

BBLPUTD EQU *
	IN	BBLCS		* GET BUBBLE STATUS
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  CALL NEWLINE			* UNCOMMENT FOR VERBOSE
	POP	B		* RESTORE BC
	POP	D		* RESTORE DE
	RET			* RETURN TO CALL

* ********************************************************************
* **************  BUBBLE READ DATA FROM BUBBLE INTO RAM  *******************
*   NAME: BBLREAD
*   FUNCTION: READS BUBBLE DATA AND PUTS INTO RAM
*   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR. 40H OR 42H = SUCCESS
*   USER IO: NONE
*   DESTROYS: A,F/F'S
*   CALLS: BBLFFR,BBL_LPR,BBL_BYTES,BBLPUT
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	BARL <- LSB OF BUBBLE ADDRESS
* 	BARH <- MSB OF BUBBLE ADDRESS
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	DE <- STARTING RAM ADDRESS OF DESTINATION
* 	CALL BBLREAD
* * ********************************************************************
BBLREAD EQU 	*
	DI			* DISABLE INTERRUPTS
	PUSH	D		* SAVE DE
	PUSH	H		* SAVE HL
	CALL	BBLABRT		* ABORT ANY COMMANDS BEING PROCESSED
	CALL	BBLFFR		* CALL BUBBLE FIFO RESET ROUTINE
	XRI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLRDDN		* IF DIDN'T FINSIH ABORT, WE ARE DONE WITH ERROR
	CALL	BBLCLBL		* CALCULATE AND LOAD BLOCK LENGTH TO BUFFER
	MVI	A,BBLEV		* GET ENABLE BYTE VALUE
	STA	BBLER		* BUBBLE ENABLE VALUE  -> BUFFER
	CALL	BBLPRL		* CALL LOAD PARAMETRIC REGISTER
	CALL	BBLGET		* READ BUBBLE DATA
	LXI	H,0FFFFH	* INITIALIZE TIMEOUT COUNTER
BBLRDLP EQU	*
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* PUT BUSY BIT INTO CARRY
	JNC	BBLRDDN		* IF NOT BUSY, RETURN
	DCX	H		* DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* SET ANY BITS IN H THAT ARE SET
	ORA	L		* DO THE SAME FOR ANY BITS IN L
	JNZ	BBLRDLP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLRDDN EQU	*
	POP	H		* RESTORE HL
	POP	D		* RESTORE DE
	IN	BBLCS		* GET BUBBLE STATUS
	EI			* ENABLE INTERRUPTS
	RET			* RETURN TO CALL


* ********************************************************************
* **************  BUBBLE WRITE DATA FROM RAM INTO BUBBLE  *******************
*   NAME: BBLWRIT
*   FUNCTION: WRITES MEMORY DATA TO THE BUBBLE
*   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
*   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR. 40H OR 42H = SUCCESS
*   USER IO: NONE
*   DESTROYS: A,F/F'S
*   CALLS: BBLFFR,BBL_LPR,BBL_BYTES,BBLPUT
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	BARL <- LSB OF BUBBLE ADDRESS
* 	BARH <- MSB OF BUBBLE ADDRESS
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	DE <- STARTING MEMORY ADDRESS OF SOURCE DATA
* 	CALL BBLWRIT
* * ********************************************************************
BBLWRIT EQU	*
	DI			* DISABLE INTERRUPTS
	PUSH	H		* SAVE HL
	CALL	BBLABRT		* ABORT ANY COMMANDS BEING PROCESSED
	CALL	BBLFFR		* CALL BUBBLE FIFO RESET ROUTINE
	XRI	BSROCCM		* ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLWRDN		* IF DIDN'T FINISH ABORT, WE ARE DONE BUT WITH ERROR
	CALL	BBLCLBL		* CALCULATE AND LOAD BLOCK LENGTH TO BUFFER
	MVI	A,BBLEV		* GET ENABLE BYTE VALUE
	STA	BBLER		* BUBBLE ENABLE VALUE  -> BUFFER
	CALL	BBLPRL		* CALL LOAD PARAMETRIC REGISTER
	CALL	BBLPUT		* WRITE BUBBLE DATA
	LXI	H,0FFFFH	* INITIALIZE TIMEOUT COUNTER
BBLWRLP EQU *
	IN	BBLCS		* GET BUBBLE STATUS
	RLC			* TEST FOR BUSY BIT
	JNC	BBLWRDN		* IF NOT BUSY, CLEAN UP AND RETURN
	DCX	H		* IF STILL BUSY, DECREMENT TIMEOUT COUNTER
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* SET ANY BITS IN H THAT ARE SET
	ORA	L		* DO THE SAME FOR ANY BITS IN L
	JNZ	BBLWRLP		* HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLWRDN EQU	*
	POP	H		* RESTORE HL
	IN	BBLCS		* GET BUBBLE STATUS
	EI			* ENABLE INTERRUPTS
	RET			* RETURN TO CALL


* ********************************************************************
* ***********  BUBBLE CALCULATE AND LOAD BLOCK LENGTH  ***************
*   NAME: BBLCLBL
*   FUNCTION: CALCULATES THE BLOCK LENGTH AND LOADS INTO BUFFER FOR REGISTER LOAD
*   INPUTS: HL=NUMBER OF BYTES TO READ OR WRITE
*   OUTPUTS: BLOCK LENGTH LOADED INTO LSB REGISTER
*   USER IO: NONE
*   DESTROYS: A,F/F'S
*   CALLS:
*   DESCRIPTION:
* 	TO USE SUBROUTINE:
* 	HL <- NUMBER OF BYTES TO TRANSFER
* 	RESULT: CALCULATED BLOCK LENGTH -> BBLRL
* * ********************************************************************
BBLCLBL  EQU	*
	PUSH	B		* B=# OF PAGES, C=NUMBER OF BYTES LEFT ON THIS PAGE
	PUSH	H		* SAVE THE ORIGINAL COUNT
*  CALL	SENDHL			* UNCOMMENT FOR VERBOSE
	MVI	C,BBLBPP	* BUBBLE BYTES PER PAGE VALUE
	MVI	B,01D		* STARTING VALUE = 1 PAGE


BBLCLLP EQU *
	DCR	C
	JP	BBLCL1		* IF BYTES LEFT ON THIS PAGE, CONTINUE
	MVI	C,BBLBPP-1	* RELOAD BYTES PER PAGE
	INR	B		* SPILL OVER INTO ANOTHER PAGE SO INCREASE PAGE COUNT

BBLCL1 EQU	*
	DCX	H		* DECREMENT NUMBER OF BYTES LEFT
	XRA	A		* CLEAR ACCUMULATOR
	ORA	H		* SEE IF BYTE COUNT IS ZERO BY ADDING BITS TO ACCUMULATOR
	ORA	L		* FIRST H THEN L
	JNZ	BBLCLLP		* NOT ZERO, DO ANOTHER BYTE



*  MVI A,'='			* UNCOMMENT FOR VERBOSE
*  CALL CO			* UNCOMMENT FOR VERBOSE
	MOV	A,B		* MOVE NUMBER OF PAGES (BLOCKS) NEEDED INTO A
	STA	BBLRL		* NUMBER OF BLOCKS USED ROUNDED UP -> BUFFER
*  CALL HO			* UNCOMMENT FOR VERBOSE
*  MVI A,'r'			* UNCOMMENT FOR VERBOSE
*  CALL CO			* UNCOMMENT FOR VERBOSE
	MOV	A,C
	STA	BBLPUC		* NUMBER OF EMPTY PLACES LEFT IN PAGE  -> BUFFER
*  CALL	HO			* UNCOMMENT FOR VERBOSE
*  CALL	NEWLINE			* UNCOMMENT FOR VERBOSE
	POP	H
	POP	B
 	RET
